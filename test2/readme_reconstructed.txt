CSE 422S - Operating Systems Organization
Lab 3: Multiplexed Inter-Process Communication
Students:
Preston Meek, meek@wustl.edu
Chiagozie Okoye, c.i.okoye@wustl.edu

*** Server Design ***
    Beginning at Step 3, the server performs basic checks of command line
arguments passed to it on invocation. In building this approach, we defined an enum ret_type
with various return values, this defined in /server/include/util.h.
    For the functionality of the server's setup with the fragment files,
/server/src/filespec.c was made to write helper functions that declutter main.c.
    Dynamic memory was used to allow for an arbitrary count of fragment files.
We hold a dynamically allocated array of pointers to chars with space for
4 pointers to fragment file path names. In a loop, the program continually reads
available lines from the filespec, keeping track of how many files it has read and
in the array, the array's size is doubled; otherwise, the next pointer in the
array is updated to be the pointer returned by malloc() for the subsequent string.
At the end of this loop, any additional, unused memory is tripped with realloc().
The final steps of this helper function open the files associated with the file
names and stores them into an array of file descriptors defined in main().
    // TODO: should we free the array of path names here?
    Step 4's implementation of the socket followed as in studios, using a helper
function in /server/src/socket.c to handle setting up the socket, returning the fd
    For I/O multiplexing, Linux's epoll interface was chosen. Originally, poll was
our choice, poll chosen over select() because poll neither required select()'s
fd_set to be reinitialized after each call nor the work of indirectly checking values
between 0 and nfds. In the end, though, epoll() was chosen over poll() because
epoll() allows data to be packaged into the elements it will keep track of; in
our case, a file descriptor. Storing the fds into the epoll structs was simpler
because poll() would require us to manage separate array(s).
    Back in main(), the server waits for connections, alerted of such by epoll().
it checks that it has not already accepted the maximum needed connections (the total
number of fragment files). If it has already accepted enough clients, the server
closes the connection, causing the client to also quit (more on this later). In
to the client, the work being the contents of a file fragment.
    During the acquisition of the connection, the server also adds the clients to
the epoll instance to be tracked for I/O. When the client sends data, epoll()
returns and the server handles reading in data. Reads and writes are handled
by a helper function defined in /shared/src/rw.c. For each number—line pair, the
server adds it to an AVL tree. When all data has been read in from a client,
the server removes the client from the list of items to be checked by epoll().
    // TODO: Possibly update the following!!!
    When all clients have returned with data, the while() loop is broken. The
server now performs the task of merging the sorted data, but this was handled by
the self-balancing AVL tree. Now, the server can perform an in-order traversal,
a known recursive algorithm, to write all the data to the output file.


*** Client Design ***
    Much like the server, the client begins with parsing command line arguments.
The arguments are used to create a socket that connects to the server's socket.
Without need for I/O multiplexing, the client can sit and wait for data from its
connection. The client reads in data, ensures it has a line number and line, and
inserts it into an AVL tree. The AVL tree, by nature, orders the data. Thus, when
all data is read in from the socket, the client writes back the sorted lines by
performing an in-order traversal of the tree.


*** Build Instructions ***
Provided with this repository is a Makefile located in the main working directory.
When the command 'make' is issued, all .c files in respective /src directories
are compiled into executables stored in /build folders.

// TODO: GO BACK AND COMMENT GPT CODE WITH EXPLANATIONS!!!!

*** Testing & Evaluation ***
A shell script was written to aid in testing. It is located in the main 
directory, test_lab.sh. Running the script runs several test cases (to be 
summarized). To run this script, though, the user must run it from the shell, 
that is, without issuing the 'qlogin' command to enter the Linx Lab.


*** Attributions ***
The following is a list of attributions to resources used in completing this lab.
This includes references to the textbook and responses from generative AI 
such as ChatGPT. For the generative AI case, the pasted text is shortened to 
the most relevant parts for readability (including emojis ChatGPT generated 
was viewed as unnecessary). When code generated by AI is used in the source 
files, it is commented with student understandings.

[1] Pointer-Walking for fprintf()
Prompt:
"""
    With the following, how can I change the sscanf() call to maintain 
    any spaces and tabs after the first space between the line number and the 
    string?
        sscanf(line, "%u %[^\n]", &line_number, line_text);
        fprintf(output, "%s\n", line_text);
    The value of line is something like the following:

    0 Hello, it is a
    1              wonderful day!
    2 What can we do
    3              on this beautiful day?
"""
ChatGPT:
"""
    unsigned int line_number;
    char line[256];
    char line_text[256];

    char *p = line;
    sscanf(p, "%u", &line_number);

    // Skip digits
    while (*p && (*p >= '0' && *p <= '9'))

    // Now `p` is at the first space or tab after the number

    // DO NOT skip spaces or tabs — we want to keep them
    // Just copy everything from here
    strcpy(line_text, p);

    // Example: write it back
    fprintf(output, "%s\n", line_text);
"""


[2] Makefile
Prompt: 
"""
    can you make me a super basic makefile? source files in src folder, 
    header files in include folder. For c not C++
"""

ChatGPT:
// As seen in ./Makefile, though extended by the user to build multiple 
// binaries at once
// TODO: maybe just copy paste it here...


[3] 
